worker_processes auto;
error_log logs/error.log info;
pid logs/nginx.pid;

events {
    worker_connections 1024;
}

http {
    include mime.types;
    default_type application/json;

    # Security & Performance Settings
    client_max_body_size 10M;
    client_body_buffer_size 128k;
    client_header_buffer_size 1k;
    large_client_header_buffers 4 8k;

    # Timeouts
    client_body_timeout 12s;
    client_header_timeout 12s;
    keepalive_timeout 65s;
    send_timeout 10s;

    # Proxy Timeouts
    proxy_connect_timeout 10s;
    proxy_send_timeout 30s;
    proxy_read_timeout 30s;
    proxy_buffering on;
    proxy_buffer_size 4k;
    proxy_buffers 8 4k;
    proxy_busy_buffers_size 8k;

    # Gzip Compression
    gzip on;
    gzip_vary on;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript
               application/json application/javascript application/xml+rss
               application/rss+xml font/truetype font/opentype
               application/vnd.ms-fontobject image/svg+xml;
    gzip_proxied any;
    gzip_min_length 256;
    gzip_disable "msie6";

    # Real IP detection (for load balancers/proxies)
    # If behind CloudFlare/proxy, uncomment these:
    # set_real_ip_from 127.0.0.1;          # Trust localhost
    # set_real_ip_from 173.245.48.0/20;    # CloudFlare IPs (example)
    # real_ip_header X-Forwarded-For;
    # real_ip_recursive on;

    # Use X-Forwarded-For if available, fallback to direct connection
    map $http_x_forwarded_for $client_real_ip {
        default $remote_addr;
        ~^([0-9.]+) $1;  # Extract first IP from X-Forwarded-For
    }

    # Generate request_id if client doesn't provide one
    map $http_x_request_id $request_id_value {
        default $http_x_request_id;
        ""      $request_id;
    }

    # Track rate limiting status
    map $status $is_rate_limited {
        default false;
        429     true;
        302     true;
    }

    log_format json_combined escape=json '{'
        '"timestamp": "$time_iso8601",'
        '"category": "system",'
        '"type": "http_access",'
        '"service": "nginx_gateway",'
        '"request_id": "$request_id_value",'
        '"remote_ip": "$client_real_ip",'
        '"x_forwarded_for": "$http_x_forwarded_for",'
        '"method": "$request_method",'
        '"url": "$request_uri",'
        '"status": $status,'
        '"rate_limited": $is_rate_limited,'
        '"user_agent": "$http_user_agent",'
        '"nginx_latency_s": $request_time,'
        '"backend_latency_s": "$upstream_response_time",'
        '"user_id": "$upstream_http_x_user_id"'
    '}';

    access_log logs/access.log json_combined;

    # Shared memory zones for rate limiting (10m = ~160k keys)
    lua_shared_dict rate_limit_auth 10m;
    lua_shared_dict rate_limit_payment 10m;
    lua_shared_dict rate_limit_admin 10m;

    upstream public_server {
        server 127.0.0.1:8001 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    upstream admin_server {
        server 127.0.0.1:8002 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    server {
        listen 8080;
        # SSL Configuration (for production on port 443)
        # listen 443 ssl http2;
        # ssl_certificate /path/to/cert.pem;
        # ssl_certificate_key /path/to/key.pem;
        # ssl_protocols TLSv1.2 TLSv1.3;
        # ssl_ciphers HIGH:!aNULL:!MD5;
        # ssl_prefer_server_ciphers on;

        server_name localhost;

        # Security Headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
        add_header Permissions-Policy "geolocation=(), microphone=(), camera=()" always;
        # add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always; # Enable after SSL

        # Hide nginx version
        server_tokens off;

        location /health {
            access_log off;
            return 200 '{"status":"healthy"}\n';
            add_header Content-Type application/json;
        }

        location /api/auth/ {
            # CORS Headers
            add_header Access-Control-Allow-Origin "http://localhost:4321" always;
            add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
            add_header Access-Control-Allow-Headers "Content-Type, Authorization, X-Request-ID" always;
            add_header Access-Control-Allow-Credentials "true" always;
            add_header Access-Control-Max-Age "3600" always;

            # Handle preflight OPTIONS request
            if ($request_method = 'OPTIONS') {
                add_header Access-Control-Allow-Origin "http://localhost:4321" always;
                add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
                add_header Access-Control-Allow-Headers "Content-Type, Authorization, X-Request-ID" always;
                add_header Access-Control-Allow-Credentials "true" always;
                add_header Access-Control-Max-Age "3600" always;
                add_header Content-Length 0;
                add_header Content-Type "text/plain; charset=utf-8";
                return 204;
            }

            access_by_lua_block {
                local cache = ngx.shared.rate_limit_auth
                local client_ip = ngx.var.client_real_ip
                local key = "auth:" .. client_ip

                -- Atomic in-memory increment with 60s expiry
                local count, err = cache:incr(key, 1, 0, 60)

                if not count then
                    ngx.log(ngx.ERR, "Rate limit cache error: ", err)
                    -- Fail open on cache error (allow request but log)
                    count = 0
                end

                if count > 10 then
                    -- Log to Redis for monitoring (non-blocking)
                    local redis = require "resty.redis"
                    local red = redis:new()
                    red:set_timeouts(100, 100, 100)
                    if red:connect("127.0.0.1", 6380) then
                        red:lpush("rate_limit:violations",
                            string.format("auth:%s:%d", client_ip, count))
                        red:expire("rate_limit:violations", 3600)
                        red:close()
                    else
                        ngx.log(ngx.WARN, "Redis unavailable for rate limit logging")
                    end

                    return ngx.redirect("/honeypot")
                end
            }
            proxy_pass http://public_server;
            proxy_set_header X-Request-ID $request_id_value;
            proxy_set_header X-Real-IP $client_real_ip;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Host $host;
        }

        location /api/payment/ {
            access_by_lua_block {
                local cache = ngx.shared.rate_limit_payment
                local client_ip = ngx.var.client_real_ip
                local user_id = ngx.var.http_x_user_id or client_ip
                local key = "payment:" .. user_id

                -- Atomic in-memory increment with 60s expiry
                local count, err = cache:incr(key, 1, 0, 60)

                if not count then
                    ngx.log(ngx.ERR, "Rate limit cache error: ", err)
                    count = 0
                end

                if count > 100 then
                    -- Log to Redis for monitoring (non-blocking)
                    local redis = require "resty.redis"
                    local red = redis:new()
                    red:set_timeouts(100, 100, 100)
                    if red:connect("127.0.0.1", 6380) then
                        red:lpush("rate_limit:violations",
                            string.format("payment:%s:%d", user_id, count))
                        red:expire("rate_limit:violations", 3600)
                        red:close()
                    else
                        ngx.log(ngx.WARN, "Redis unavailable for rate limit logging")
                    end

                    ngx.status = 429
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error":"Rate limit exceeded","retry_after":60}')
                    return ngx.exit(429)
                end
            }
            proxy_pass http://public_server;
            proxy_set_header X-Request-ID $request_id_value;
            proxy_set_header X-Real-IP $client_real_ip;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /api/admin/ {
            access_by_lua_block {
                local cache = ngx.shared.rate_limit_admin
                local client_ip = ngx.var.client_real_ip
                local key = "admin:" .. client_ip

                -- Atomic in-memory increment with 60s expiry
                local count, err = cache:incr(key, 1, 0, 60)

                if not count then
                    ngx.log(ngx.ERR, "Rate limit cache error: ", err)
                    count = 0
                end

                if count > 120 then
                    -- Log to Redis for monitoring (non-blocking)
                    local redis = require "resty.redis"
                    local red = redis:new()
                    red:set_timeouts(100, 100, 100)
                    if red:connect("127.0.0.1", 6380) then
                        red:lpush("rate_limit:violations",
                            string.format("admin:%s:%d", client_ip, count))
                        red:expire("rate_limit:violations", 3600)
                        red:close()
                    else
                        ngx.log(ngx.WARN, "Redis unavailable for rate limit logging")
                    end

                    ngx.status = 429
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error":"Rate limit exceeded","retry_after":60}')
                    return ngx.exit(429)
                end
            }
            proxy_pass http://admin_server;
            proxy_set_header X-Request-ID $request_id_value;
            proxy_set_header X-Real-IP $client_real_ip;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location = /honeypot {
            root html;
            try_files /honeypot.html =404;
            add_header Content-Type text/html;
            add_header X-Trolled-By "K-Services Security Team";

            # Special logging for DOS attempts
            access_log logs/dos_attempts.log json_combined;
        }

        location = /favicon.ico {
            log_not_found off;
            access_log off;
            return 204;
        }

        # Catch-all for unknown paths - redirect to honeypot
        location / {
            return 302 /honeypot;
        }
    }
}
